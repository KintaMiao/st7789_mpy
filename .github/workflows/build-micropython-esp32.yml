name: Build MicroPython ESP32 Firmware with ST7789 Driver

on:
  push:
    branches: [ main, master ] # Adjust as needed
  pull_request:
    branches: [ main, master ] # Adjust as needed
  workflow_dispatch: # Allows manual triggering

# Workflow-level environment variables
# This 'env' block MUST be at the top level (no indentation)
env:
  # --- USER CONFIGURABLE (derived from your README.md) ---
  # Path from the root of your repository to the directory containing the
  # st7789 C module files and its 'micropython.cmake' file.
  # If your repo is 'st7789_mpy' and the files are in 'st7789_mpy/st7789/', set this to "st7789".
  USER_C_MODULE_PATH: "st7789" # IMPORTANT: Adjust if your module is in a different subfolder

  # MicroPython version (from your README)
  MPY_VERSION: "v1.20.0"

  # ESP-IDF Docker image version (v4.4.4 mentioned, so v4.4 tag is appropriate)
  ESP_IDF_VERSION: "v4.4"
  # --- END USER CONFIGURABLE ---

jobs:
  build_firmware:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        # Define your target ESP32 boards here (from your README and common boards)
        # These should correspond to the BOARD names in micropython/ports/esp32/boards
        target:
          - ESP32_GENERIC       # For "GENERIC-7789" and "GENERIC_SPIRAM-7789" (SPIRAM needs sdkconfig)
          - ESP32_C3_GENERIC    # For "GENERIC_C3"
          - LOLIN_S2_MINI
          - TTGO_TDISPLAY       # For "T-DISPLAY"
          - LILYGO_TTGO_TWATCH  # For "T-Watch-2020" (check exact board name if this fails)
        # Add more specific boards as needed.
        # For SPIRAM on ESP32_GENERIC, you might need to include a custom sdkconfig.board or ensure
        # the default for v1.20.0 enables it if you want it for ESP32_GENERIC.
        # Or use a board that has SPIRAM by default like ESP32_GENERIC_S3_SPIRAM_OCT (for S3).

    container:
      # This line (L45 in your original error) needs env.ESP_IDF_VERSION
      # Ensure the 'env:' block above is correctly defined and not indented.
      image: espressif/esp-idf:${{ env.ESP_IDF_VERSION }}

    steps:
      - name: Checkout Your Repository (e.g., st7789_mpy)
        uses: actions/checkout@v4
        with:
          path: main_project # Checkout your project (which contains st7789 module)

      - name: Clone MicroPython
        uses: actions/checkout@v4
        with:
          repository: micropython/micropython
          path: micropython
          ref: ${{ env.MPY_VERSION }}
          submodules: 'recursive' # Fetch submodules like libffi

      - name: Set up ESP-IDF environment
        run: |
          echo "Sourcing ESP-IDF environment..."
          . $IDF_PATH/export.sh
          echo "IDF_PATH=$IDF_PATH" >> $GITHUB_ENV
          echo "IDF_TOOLS_PATH=$IDF_TOOLS_PATH" >> $GITHUB_ENV
          # The v4.4 image should have tools pre-installed. If not, uncomment install.sh:
          # $IDF_PATH/install.sh esp32,esp32s2,esp32s3,esp32c3 # Or list specific chips

      - name: Build mpy-cross
        working-directory: micropython/mpy-cross
        run: |
          echo "Building mpy-cross..."
          make -j$(nproc)

      - name: Build Firmware for ${{ matrix.target }}
        working-directory: micropython/ports/esp32
        env:
          # Construct the path to the user C module's .cmake file
          # This path is relative from 'micropython/ports/esp32/'
          # Example: ../../../main_project/st7789/micropython.cmake
          USER_C_MODULES_CMAKE_FILE: "../../../main_project/${{ env.USER_C_MODULE_PATH }}/micropython.cmake"
        run: |
          echo "Building firmware for ${{ matrix.target }}"
          echo "User C Module CMake file: ${USER_C_MODULES_CMAKE_FILE}"

          # Check if the user C module CMake file exists
          if [ ! -f "${USER_C_MODULES_CMAKE_FILE}" ]; then
            echo "Error: User C module CMake file '${USER_C_MODULES_CMAKE_FILE}' not found."
            echo "Please check:"
            echo "  1. The USER_C_MODULE_PATH env variable in your workflow ('${{ env.USER_C_MODULE_PATH }}')."
            echo "  2. That 'micropython.cmake' exists in that directory within your project."
            echo "Listing contents of 'main_project/${{ env.USER_C_MODULE_PATH }}' (relative to GITHUB_WORKSPACE):"
            ls -R "../../../main_project/${{ env.USER_C_MODULE_PATH }}"
            exit 1
          fi

          # Clean previous build
          # Using USER_C_MODULES to point directly to the .cmake file as per your README's build style
          make BOARD=${{ matrix.target }} USER_C_MODULES="${USER_C_MODULES_CMAKE_FILE}" FROZEN_MANIFEST="" clean

          # Build submodules (like tinyusb, esp-camera if used by board)
          make BOARD=${{ matrix.target }} USER_C_MODULES="${USER_C_MODULES_CMAKE_FILE}" FROZEN_MANIFEST="" -j$(nproc) submodules

          # Build the firmware
          make BOARD=${{ matrix.target }} USER_C_MODULES="${USER_C_MODULES_CMAKE_FILE}" FROZEN_MANIFEST="" -j$(nproc)

      - name: Prepare Artifacts for ${{ matrix.target }}
        id: prep_artifacts
        run: |
          FIRMWARE_DIR="micropython/ports/esp32/build-${{ matrix.target }}"
          ARTIFACT_NAME="firmware-${{ matrix.target }}"
          echo "Firmware directory: ${FIRMWARE_DIR}"
          ls -lh "${FIRMWARE_DIR}"

          # bootloader.bin path can vary slightly with IDF versions/board configs
          BOOTLOADER_PATH="${FIRMWARE_DIR}/bootloader/bootloader.bin"
          if [ ! -f "${BOOTLOADER_PATH}" ]; then
             BOOTLOADER_PATH="${FIRMWARE_DIR}/bootloader.bin" # Fallback for older structures
          fi
          if [ ! -f "${BOOTLOADER_PATH}" ]; then
             echo "Error: bootloader.bin not found in expected locations."
             exit 1
          fi

          echo "Preparing artifact directory: artifact_temp/${ARTIFACT_NAME}"
          mkdir -p "artifact_temp/${ARTIFACT_NAME}"
          cp "${FIRMWARE_DIR}/firmware.bin" "artifact_temp/${ARTIFACT_NAME}/"
          cp "${FIRMWARE_DIR}/partitions.bin" "artifact_temp/${ARTIFACT_NAME}/"
          cp "${BOOTLOADER_PATH}" "artifact_temp/${ARTIFACT_NAME}/"

          # Optional: include .map and .elf files for debugging
          if [ -f "${FIRMWARE_DIR}/micropython.map" ]; then cp "${FIRMWARE_DIR}/micropython.map" "artifact_temp/${ARTIFACT_NAME}/"; fi
          if [ -f "${FIRMWARE_DIR}/micropython.elf" ]; then cp "${FIRMWARE_DIR}/micropython.elf" "artifact_temp/${ARTIFACT_NAME}/"; fi

          # Set outputs for artifact upload step (using new GITHUB_OUTPUT method)
          echo "artifact_path=artifact_temp/${ARTIFACT_NAME}" >> $GITHUB_OUTPUT
          echo "artifact_name=${ARTIFACT_NAME}" >> $GITHUB_OUTPUT

      - name: Upload Firmware Artifact for ${{ matrix.target }}
        uses: actions/upload-artifact@v4 # Updated to v4
        with:
          name: ${{ steps.prep_artifacts.outputs.artifact_name }}
          path: ${{ steps.prep_artifacts.outputs.artifact_path }}
          if-no-files-found: error # Fail the workflow if firmware files are not found
